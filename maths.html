<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Speed Challenge - Time Limit</title>
    <!-- Use a cool, tech-focused font -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4CAF50; /* Green */
            --secondary-color: #ffd700; /* Gold */
            --background-color: #1a1a2e; /* Dark Blue/Purple */
            --card-color: #2c2c54; /* Medium Blue/Purple */
            --text-color: #e0e0e0;
            --font-family: 'Orbitron', sans-serif;
            
            /* NEW NAVIGATION COLORS */
            --prev-color: #00bcd4; /* Cyan/Teal for Previous */
            --next-color: #ff9800; /* Orange/Amber for Next */
        }

        /* --- Rainbow Gradient Background Animation --- */
        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        body {
            font-family: var(--font-family);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            /* Changed min-height to height: 100% and added overflow: auto to ensure scrolling is possible */
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            
            /* Rainbow Background */
            background: linear-gradient(135deg, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #9400D3);
            background-size: 400% 400%;
            animation: gradient-shift 15s ease infinite;
            position: relative;
            overflow-y: auto; /* Ensure scrolling on body if content is too large */
        }

        /* --- Math Emoji Overlay Pattern --- */
        body::before {
            content: "∑ π ∞ ÷ × + - = ∫ % ² ³ ± ≠ ≥ ≤ ² ³"; /* Math symbols */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.08; /* Subtle transparency */
            pointer-events: none;
            z-index: -1;
            font-size: 2.5rem;
            word-wrap: break-word;
            line-height: 1.5;
            white-space: pre-wrap;
            color: #ffffff;
            overflow: hidden;
            /* Rotate and scale to create a dynamic, dense pattern */
            transform: scale(2) rotate(30deg);
        }

        .game-app {
            /* Added slight transparency so the rainbow background peeks through */
            background-color: rgba(44, 44, 84, 0.95); 
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
            max-width: 500px; 
            width: 100%;
            text-align: center;
            border: 3px solid var(--primary-color);
            transition: all 0.3s ease;
            z-index: 10; /* Keep the card above the background */
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 1.8rem;
            text-shadow: 0 0 5px var(--primary-color);
        }

        /* --- Start Screen Styling --- */
        #start-screen h1 {
            margin-top: 0;
            margin-bottom: 40px;
        }
        
        .difficulty-selector {
            margin-bottom: 25px;
            text-align: left;
            color: var(--text-color);
        }

        .difficulty-selector label {
            display: block;
            margin-bottom: 8px;
            font-weight: 700;
            color: var(--secondary-color);
            font-size: 1.1rem;
        }

        #difficulty-level, #time-limit-level {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid var(--primary-color);
            background-color: #111122;
            color: var(--text-color);
            font-size: 1rem;
            font-family: var(--font-family);
            appearance: none; 
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffd700'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 20px;
            cursor: pointer;
        }
        
        /* --- Game Screen Styling --- */
        #game-screen {
            display: none; /* Hidden by default */
            position: relative; 
        }
        
        .stats-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding: 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .stat-item {
            font-size: 1rem;
            font-weight: 700;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 70px;
        }

        .stat-item.q-number {
            font-size: 0.9rem;
            color: #ccc;
        }
        
        .stat-item span {
            font-size: 1.3rem;
            line-height: 1;
        }

        #timer {
            color: #ff6347; /* Tomato Red */
        }

        #score {
            color: var(--secondary-color); /* Gold */
        }

        #question-display {
            font-size: 2.2rem;
            font-weight: 700;
            margin: 30px 0;
            min-height: 50px; 
            transition: opacity 0.3s ease; 
        }
        
        /* --- Option/Button Styling --- */
        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .option-button {
            background: #4a4a70;
            color: var(--text-color);
            border: none;
            padding: 15px 10px;
            border-radius: 8px;
            font-size: 1.4rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 0 0 #313150;
            transition: all 0.1s ease;
            text-transform: none;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .option-button:hover:not(:disabled) {
            background: #5a5a8a;
        }

        .option-button:active:not(:disabled) {
            box-shadow: 0 0 0 0 #313150;
            transform: translateY(4px);
        }
        
        .option-button:disabled {
            cursor: default;
            opacity: 0.7;
        }

        .option-button.correct {
            background-color: var(--primary-color);
            box-shadow: 0 4px 0 0 #388e3c;
            color: var(--background-color);
        }

        .option-button.incorrect {
            background-color: #ff6347;
            box-shadow: 0 4px 0 0 #cc503a;
        }

        /* --- Navigation Button Styling --- */
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
            gap: 10px;
        }

        .nav-button {
            /* Base style for all nav buttons */
            color: var(--background-color); /* Dark text for contrast */
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 3px 0 0; /* Box shadow defined by color below */
            transition: all 0.1s ease;
            flex: 1; 
            text-transform: uppercase;
        }

        /* Previous Button Specific Styling */
        #prev-question-button {
            background: var(--prev-color);
            box-shadow: 0 3px 0 0 #008ba3; /* Darker cyan */
        }
        #prev-question-button:active:not(:disabled) {
            box-shadow: 0 0 0 0 #008ba3;
        }
        
        /* Next Button Specific Styling */
        #next-question-button {
            background: var(--next-color);
            box-shadow: 0 3px 0 0 #cc7b00; /* Darker orange */
        }
        #next-question-button:active:not(:disabled) {
            box-shadow: 0 0 0 0 #cc7b00;
        }

        /* Disabled State (applies to both) */
        .nav-button:disabled {
            background: #4a4a70; /* Grayed out background */
            box-shadow: none;
            color: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }

        .nav-button:active:not(:disabled) {
            transform: translateY(3px);
        }


        .main-button {
            margin-top: 30px;
            background: var(--primary-color);
            color: var(--background-color);
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 4px 0 0 #388e3c; 
            transition: all 0.1s ease;
            width: 100%;
            text-transform: uppercase;
        }

        .main-button:active {
            box-shadow: 0 0 0 0 #388e3c;
            transform: translateY(4px);
        }

        /* --- Message Box Styling (for Game Over) --- */
        .message-box {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .message-content {
            background-color: var(--card-color);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
            text-align: center;
            max-width: 90%;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .message-content h2 {
            color: var(--secondary-color);
            margin-bottom: 15px;
        }
        
        /* --- Footer Styling --- */
        #game-footer {
            margin-top: 20px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
            color: #999;
            text-align: center;
            font-weight: 400;
            letter-spacing: 0.5px;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 600px) {
            .game-app {
                padding: 20px;
                margin: 10px;
            }
            h1 {
                font-size: 1.5rem;
            }
            #question-display {
                font-size: 1.8rem;
            }
            .options-grid {
                grid-template-columns: 1fr;
            }
            .navigation-buttons {
                flex-wrap: wrap;
            }
            .nav-button {
                flex: 1 1 45%; /* Allow wrapping */
            }
        }
    </style>
</head>
<body>

    <div class="game-app">
        <h1>MATH SPEED CHALLENGE</h1>
        
        <!-- Start Screen -->
        <div id="start-screen">
            <div class="difficulty-selector">
                <label for="difficulty-level">Select Difficulty:</label>
                <select id="difficulty-level">
                    <option value="easy">Easy (Tables & Basic Arithmetic)</option>
                    <option value="intermediate">Intermediate (Integers & Two-Step)</option>
                    <option value="advanced">Advanced (Exponents & Three-Step)</option>
                    <option value="impossible">Impossible (Decimals & Complex Order)</option>
                </select>
            </div>
            
            <!-- Time Limit Selection (This is the one you asked about!) -->
            <div class="difficulty-selector">
                <label for="time-limit-level">Set Time Limit Per Question:</label>
                <select id="time-limit-level">
                    <option value="10">10 seconds</option>
                    <option value="15" selected>15 seconds</option>
                    <option value="20">20 seconds</option>
                    <option value="25">25 seconds</option>
                    <option value="30">30 seconds</option>
                </select>
            </div>
            
            <button id="start-game-button" class="main-button">START CHALLENGE</button>
        </div>

        <!-- Game Screen -->
        <div id="game-screen">
            <div class="stats-bar">
                <div class="stat-item q-number">Question<span id="question-number-display">0 of 100</span></div>
                <div class="stat-item">Time Left<span id="timer">15</span></div>
                <div class="stat-item">Score<span id="score">0</span></div>
            </div>

            <div id="question-display">
                <!-- Question will appear here -->
            </div>

            <div class="options-grid" id="options-container">
                <button class="option-button" data-option="1"></button>
                <button class="option-button" data-option="2"></button>
                <button class="option-button" data-option="3"></button>
                <button class="option-button" data-option="4"></button>
            </div>
            
            <div class="navigation-buttons">
                <!-- Cyan/Teal for Previous -->
                <button id="prev-question-button" class="nav-button">← Previous Question</button>
                <!-- Orange/Amber for Next -->
                <button id="next-question-button" class="nav-button">Next Question →</button>
            </div>
            
        </div>
        
        <!-- FOOTER (This is the one you asked about!) -->
        <div id="game-footer">Developed by Sarvesh Ragavendar (G7A)</div>
    </div>

    <!-- Custom Message Box (for Game Over) -->
    <div id="message-box" class="message-box">
        <div class="message-content">
            <h2 id="message-title">Game Over!</h2>
            <p id="message-text">Your final score is 0.</p>
            <button id="close-message" class="main-button">Return to Start</button>
        </div>
    </div>

    <script>
        (function() {
            // Global game state variables (scoped by IIFE)
            let score = 0;
            let timeLeft = 0; 
            let timerInterval;
            let questionHistory = []; 
            let currentQuestionIndex = 0; 
            let gameRunning = false;
            
            // --- Game Configuration (TIME_PER_QUESTION is now dynamic) ---
            let TIME_PER_QUESTION = 15; // Default, overwritten at start
            const MAX_QUESTIONS = 100;

            const DIFFICULTIES = {
                easy: { maxNum: 10, operations: ['+', '-', '×'], steps: 1, allowNegatives: false, allowDivision: false, isTable: true, name: 'Easy' },
                intermediate: { maxNum: 50, operations: ['+', '-', '×'], steps: 2, allowNegatives: true, allowDivision: false, name: 'Intermediate' },
                advanced: { maxNum: 100, operations: ['+', '-', '×', '÷', '^'], steps: 3, allowNegatives: true, allowDivision: true, allowExponents: true, maxDivisor: 10, name: 'Advanced' },
                impossible: { maxNum: 200, operations: ['+', '-', '×', '÷', '^'], steps: 3, allowNegatives: true, allowDivision: true, allowExponents: true, maxDivisor: 20, decimalResult: true, name: 'Impossible' }
            };

            // DOM Elements
            const startScreen = document.getElementById('start-screen');
            const gameScreen = document.getElementById('game-screen');
            const questionDisplay = document.getElementById('question-display');
            const scoreDisplay = document.getElementById('score');
            const timerDisplay = document.getElementById('timer');
            const questionNumberDisplay = document.getElementById('question-number-display');
            const startButton = document.getElementById('start-game-button');
            const difficultySelector = document.getElementById('difficulty-level');
            const timeLimitSelector = document.getElementById('time-limit-level'); 
            const optionsContainer = document.getElementById('options-container');
            const optionButtons = document.querySelectorAll('.option-button');
            const prevButton = document.getElementById('prev-question-button');
            const nextButton = document.getElementById('next-question-button');
            const messageBox = document.getElementById('message-box');
            const messageTitle = document.getElementById('message-title');
            const messageText = document.getElementById('message-text');
            const closeMessageButton = document.getElementById('close-message');

            // --- Utility Functions ---

            /**
             * Generates a random integer between min (inclusive) and max (inclusive).
             */
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            /**
             * Shuffles an array in place using the Fisher-Yates algorithm.
             */
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            /**
             * Switches the view between the start screen and the game screen.
             */
            function switchView(viewId) {
                if (viewId === 'game') {
                    startScreen.style.display = 'none';
                    gameScreen.style.display = 'block';
                } else {
                    startScreen.style.display = 'block';
                    gameScreen.style.display = 'none';
                }
            }

            /**
             * Displays a custom message box instead of using alert() for game end.
             */
            function showMessage(title, text) {
                messageTitle.textContent = title;
                messageText.innerHTML = text; 
                
                closeMessageButton.textContent = 'Return to Start';
                closeMessageButton.onclick = () => {
                    messageBox.style.display = 'none';
                    switchView('start');
                };

                messageBox.style.display = 'flex';
            }
            
            /**
             * Generates plausible distractors (incorrect answers) for a given correct answer.
             */
            function generateDistractors(correct, config) {
                let distractors = new Set();
                const roundedCorrect = config.decimalResult ? correct : Math.round(correct);
                
                // Strategies for distractors
                const strategies = [
                    () => roundedCorrect + getRandomInt(1, 2) * (Math.random() < 0.5 ? 1 : -1),
                    () => roundedCorrect + getRandomInt(3, 5) * (Math.random() < 0.5 ? 1 : -1), 
                    () => -roundedCorrect, // Sign error
                    () => {
                        let error = Math.floor(Math.abs(roundedCorrect) * 0.1) + 1;
                        return roundedCorrect + error; // Off by a small percentage/amount
                    }
                ];

                while (distractors.size < 3) {
                    let distractor = null;
                    const strategy = strategies[getRandomInt(0, strategies.length - 1)];
                    
                    distractor = strategy();

                    if (config.decimalResult) {
                        distractor = parseFloat(distractor.toFixed(1));
                    } else {
                        distractor = Math.round(distractor);
                    }

                    if (distractor !== correct && !distractors.has(distractor) && Math.abs(distractor) < 1000) {
                        distractors.add(distractor);
                    }
                }

                return Array.from(distractors);
            }

            /**
             * Generates the core math problem structure (expression and result).
             */
            function generateProblemStructure(config) {
                const ops = config.operations.map(op => (op === '×' ? '*' : op === '÷' ? '/' : op === '^' ? '**' : op)); // Convert to JS executable ops
                
                if (config.steps === 1) {
                    let problem = generateSimpleProblem(config);
                    return { expression: problem.expression, result: problem.result };
                } else {
                    // Multi-step logic
                    const easyOps = ['+', '-', '×'].map(op => (op === '×' ? '*' : op));
                    const op1 = easyOps[getRandomInt(0, easyOps.length - 1)];
                    const op2 = easyOps[getRandomInt(0, easyOps.length - 1)];

                    let num1, num2, num3;

                    num1 = getRandomInt(1, 15);
                    num2 = getRandomInt(1, 10);
                    num3 = getRandomInt(1, 5);

                    if (config.allowNegatives) {
                        if (Math.random() < 0.5) num1 *= -1;
                        if (Math.random() < 0.5) num2 *= -1;
                        if (Math.random() < 0.5) num3 *= -1;
                    }

                    let expression, evalExpression, result;

                    if (config.allowExponents && Math.random() < 0.3) {
                        const base = num1 < 0 ? `(${num1})` : num1;
                        expression = `${num1}^2 ${op1} ${num2}`;
                        evalExpression = `${base}**2 ${op1} ${num2}`; 

                    } else if (config.allowDivision && Math.random() < 0.3) {
                        let intermediate = getRandomInt(10, 50);
                        num3 = getRandomInt(2, 5);
                        let a = intermediate + getRandomInt(1, 5);
                        let b = a - intermediate; 
                        
                        expression = `(${a} - ${b}) ÷ ${num3}`;
                        evalExpression = `((${a}) - (${b})) / ${num3}`;
                    } else {
                        expression = `(${num1} ${op1} ${num2}) ${op2} ${num3}`;
                        evalExpression = `((${num1}) ${op1} (${num2})) ${op2} (${num3})`;
                    }

                    try {
                        result = eval(evalExpression);
                    } catch (e) {
                        console.error("Evaluation error:", e, "\nExpression:", evalExpression);
                        return generateProblemStructure(config);
                    }

                    expression = expression.replace(/\*\*/g, '^').replace(/\*/g, '×').replace(/\//g, '÷');
                    
                    return { 
                        expression: expression.replace(/\+-/g, ' - ').replace(/--/g, ' + '), 
                        result: config.decimalResult ? parseFloat(result.toFixed(1)) : Math.round(result) 
                    };
                }
            }
            
            function generateSimpleProblem(config) {
                 const ops = config.operations.map(op => (op === '×' ? '*' : op === '÷' ? '/' : op === '^' ? '**' : op));
                 const operator = ops[getRandomInt(0, ops.length - 1)];
                 
                 let num1, num2, result;
                
                 if (config.isTable && Math.random() < 0.7 && operator === '*') { 
                      num1 = getRandomInt(1, 10);
                      num2 = getRandomInt(1, 10);
                      return { expression: `${num1} × ${num2}`, result: num1 * num2 };
                 }

                 num1 = getRandomInt(1, config.maxNum);
                 num2 = getRandomInt(1, config.maxNum);

                 if (config.allowNegatives) {
                     if (Math.random() < 0.5) num1 *= -1;
                     if (Math.random() < 0.5) num2 *= -1;
                 }
                 
                 let expression;
                 
                 if (operator === '+') {
                     result = num1 + num2;
                     expression = `${num1} + ${num2}`;
                 } else if (operator === '-') {
                     if (!config.allowNegatives && num1 < num2) [num1, num2] = [num2, num1];
                     result = num1 - num2;
                     expression = `${num1} - ${num2}`;
                 } else if (operator === '*') {
                     result = num1 * num2;
                     expression = `${num1} × ${num2}`;
                 } else if (operator === '/' && config.allowDivision) {
                     let divisor = getRandomInt(2, config.maxDivisor);
                     if (config.decimalResult) {
                         let targetInt = getRandomInt(5, 20);
                         let multiplier = (Math.random() < 0.5) ? 4 : 2; 
                         let remainder = getRandomInt(0, multiplier - 1);
                         
                         let dividend = targetInt * multiplier + remainder;
                         divisor = multiplier;
                         
                         result = parseFloat((dividend / divisor).toFixed(1));
                         expression = `${dividend} ÷ ${divisor}`;
                     } else {
                         result = getRandomInt(1, config.maxNum / 2);
                         let dividend = result * divisor; 
                         expression = `${dividend} ÷ ${divisor}`;
                     }
                 } else if (operator === '**' && config.allowExponents) {
                     let base = getRandomInt(2, 6);
                     let exponent = getRandomInt(2, 3);
                     result = Math.pow(base, exponent);
                     expression = `${base}^${exponent}`;
                 } else {
                    return generateSimpleProblem({ ...config, operations: ['+', '-'] });
                 }

                 return { expression: expression.replace(/\+-/g, ' - ').replace(/--/g, ' + '), result: config.decimalResult ? parseFloat(result.toFixed(1)) : Math.round(result) };
            }


            /**
             * Loads a question (generating if it doesn't exist) at a given index.
             */
            function loadQuestion(index) {
                if (!gameRunning) return;
                
                currentQuestionIndex = index;

                const config = DIFFICULTIES[difficultySelector.value];
                let q;

                // 1. Clear any running timer if moving to a new or previously answered question
                clearInterval(timerInterval);

                // 2. Check if question already exists in history
                if (questionHistory[index]) {
                    q = questionHistory[index];
                } else if (index < MAX_QUESTIONS) {
                    // 3. Generate a NEW question
                    const problem = generateProblemStructure(config); 
                    const correctOption = problem.result;
                    const distractors = generateDistractors(correctOption, config);
                    let options = [correctOption, ...distractors];
                    shuffleArray(options);

                    q = { 
                        expression: problem.expression, 
                        answer: correctOption, 
                        options: options,
                        userAnswer: null, 
                        isCorrect: null, 
                        timeSpent: 0 
                    };
                    questionHistory.push(q);
                } else {
                    return;
                }
                
                // 4. Render and Update Navigation
                renderQuestion(q);
                updateNavigationButtons();
                updateQuestionNumberDisplay();
            }

            /**
             * Renders the current question and options to the screen, adjusting for answered state.
             */
            function renderQuestion(q) {
                questionDisplay.textContent = `${q.expression} = ?`;
                
                optionButtons.forEach((button, index) => {
                    const optionValue = q.options[index];
                    button.textContent = optionValue;
                    button.setAttribute('data-answer', optionValue);
                    button.classList.remove('correct', 'incorrect');
                    
                    // If question is answered, disable buttons and show feedback
                    if (q.userAnswer !== null) {
                        button.disabled = true;
                        
                        const isOptionCorrect = parseFloat(button.getAttribute('data-answer')).toFixed(1) === q.answer.toFixed(1);
                        const isUserSelected = parseFloat(button.getAttribute('data-answer')).toFixed(1) === q.userAnswer.toFixed(1);
                        
                        if (isOptionCorrect) {
                            button.classList.add('correct');
                        } else if (isUserSelected && !q.isCorrect) {
                            button.classList.add('incorrect');
                        }
                    } else {
                        // If question is not answered, enable buttons and start timer
                        button.disabled = false;
                    }
                });

                // Timer logic update
                clearInterval(timerInterval);
                if (q.userAnswer === null) {
                    // If not answered, start the timer
                    timeLeft = TIME_PER_QUESTION; 
                    timerDisplay.textContent = timeLeft;
                    startTimerCountdown(); 
                    timerDisplay.style.color = '#ff6347';
                } else {
                    // If answered, display time taken or "Timed Out"
                    if (q.userAnswer === NaN) {
                        timerDisplay.textContent = "Timed Out";
                        timerDisplay.style.color = '#ff6347';
                    } else {
                        timerDisplay.textContent = `${q.timeSpent.toFixed(1)}s`;
                        timerDisplay.style.color = q.isCorrect ? 'var(--secondary-color)' : '#ff6347'; 
                    }
                }
            }
            
            /**
             * Handles the selection of an answer option.
             */
            function selectAnswer(selectedButton) {
                if (!gameRunning || questionHistory[currentQuestionIndex].userAnswer !== null) return;

                // Disable all buttons immediately to prevent multiple clicks
                optionButtons.forEach(btn => btn.disabled = true);
                
                const q = questionHistory[currentQuestionIndex];
                const userAnswer = parseFloat(selectedButton.getAttribute('data-answer'));
                const expectedAnswer = q.answer;
                const config = DIFFICULTIES[difficultySelector.value];

                let isCorrect = false;

                // Compare answers based on whether decimals are involved
                if (config.decimalResult) {
                    isCorrect = userAnswer.toFixed(1) === expectedAnswer.toFixed(1);
                } else {
                    isCorrect = userAnswer === expectedAnswer;
                }

                // 1. Save result to history
                clearInterval(timerInterval); // Stop the timer immediately
                q.userAnswer = userAnswer;
                q.isCorrect = isCorrect;
                // Calculate time spent: TIME_PER_QUESTION minus remaining time, rounded to 1 decimal place.
                q.timeSpent = parseFloat((TIME_PER_QUESTION - timeLeft).toFixed(1)); 

                // 2. Update overall score display
                updateScoreDisplay();

                // 3. Visual feedback
                renderQuestion(q); // Re-render to show correct/incorrect styling

                // 4. Update navigation buttons after answer is submitted
                updateNavigationButtons();
            }
            
            /**
             * Recalculates and updates the total score based on history.
             */
            function updateScoreDisplay() {
                // Score is only counted for correctly answered questions
                score = questionHistory.filter(q => q.isCorrect).length; 
                scoreDisplay.textContent = score;
            }

            /**
             * Starts or resumes the timer countdown.
             */
            function startTimerCountdown() {
                clearInterval(timerInterval);
                
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = timeLeft;

                    if (timeLeft <= 5 && timeLeft > 0) {
                        timerDisplay.style.color = '#ff6347'; // Turn red when low
                    } else if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        handleTimeOut();
                    }
                }, 1000);
            }

            /**
             * Handles the case when the timer runs out.
             */
            function handleTimeOut() {
                if (!gameRunning) return;

                const q = questionHistory[currentQuestionIndex];

                // Record failure
                q.userAnswer = NaN; // Use NaN for 'timed out' state
                q.isCorrect = false;
                q.timeSpent = TIME_PER_QUESTION; // Full time spent
                
                // Visual feedback (render to show correct answer and disabled state)
                renderQuestion(q);

                // Update navigation buttons after timeout
                updateNavigationButtons();
            }
            
            /**
             * Updates the navigation button states based on current position.
             */
            function updateNavigationButtons() {
                const q = questionHistory[currentQuestionIndex];

                // Prev button is disabled on Q1 (index 0) 
                prevButton.disabled = currentQuestionIndex === 0;
                
                const isLastQuestion = currentQuestionIndex === MAX_QUESTIONS - 1;
                
                if (isLastQuestion) {
                    nextButton.textContent = 'Finish Challenge';
                    // Allow finishing if the last question has been attempted (answered or timed out)
                    nextButton.disabled = q.userAnswer === null;
                } else {
                    nextButton.textContent = 'Next Question →'; // Added arrow back in HTML
                    // Allow navigation if the current question has been attempted
                    nextButton.disabled = q.userAnswer === null;
                }
            }

            /**
             * Updates the question number display.
             */
            function updateQuestionNumberDisplay() {
                questionNumberDisplay.textContent = `${currentQuestionIndex + 1} of ${MAX_QUESTIONS}`;
            }

            /**
             * Navigates to the next question.
             */
            function goToNextQuestion() {
                const q = questionHistory[currentQuestionIndex];

                if (currentQuestionIndex === MAX_QUESTIONS - 1) {
                    endGame();
                    return;
                }
                
                // Only allow navigation if the current question has been attempted (answered or timed out)
                if (q.userAnswer === null) return; 

                if (currentQuestionIndex < questionHistory.length - 1) {
                    loadQuestion(currentQuestionIndex + 1); // Move to existing next question
                } else if (questionHistory.length < MAX_QUESTIONS) {
                    loadQuestion(currentQuestionIndex + 1); // Generate and load new question
                }
            }

            /**
             * Navigates to the previous question.
             */
            function goToPreviousQuestion() {
                if (currentQuestionIndex > 0) {
                    loadQuestion(currentQuestionIndex - 1);
                }
            }

            /**
             * Starts or restarts the game.
             */
            function startGame() {
                // 1. Set the time limit based on selection
                TIME_PER_QUESTION = parseInt(timeLimitSelector.value, 10);

                // 2. Setup initial state
                score = 0;
                questionHistory = [];
                currentQuestionIndex = 0;
                gameRunning = true;
                updateScoreDisplay();
                switchView('game');
                
                // 3. Generate and load the first question (Q0)
                loadQuestion(0);
            }

            /**
             * Ends the game and displays the final score.
             */
            function endGame() {
                gameRunning = false;
                clearInterval(timerInterval);
                
                const finalScore = questionHistory.filter(q => q.isCorrect).length;
                const totalTimeSpent = questionHistory.reduce((sum, q) => sum + (q.timeSpent || 0), 0);
                const answeredCount = questionHistory.filter(q => q.userAnswer !== null).length;
                
                const levelName = DIFFICULTIES[difficultySelector.value].name;
                
                showMessage('Challenge Complete!', 
                    `You attempted **${answeredCount}** of ${MAX_QUESTIONS} questions in the **${levelName}** challenge. 
                    <br><br>
                    **Correct Answers: ${finalScore}**
                    <br>
                    Total Answer Time: ${totalTimeSpent.toFixed(1)} seconds.`);
            }
            
            // --- Event Listeners ---
            window.onload = function() {
                switchView('start');

                startButton.addEventListener('click', startGame);
                prevButton.addEventListener('click', goToPreviousQuestion);
                nextButton.addEventListener('click', goToNextQuestion);

                // Option buttons click 
                optionsContainer.addEventListener('click', (event) => {
                    const target = event.target;
                    if (target.classList.contains('option-button') && gameRunning && !target.disabled) {
                        selectAnswer(target);
                    }
                });
            };
        })(); // IIFE closing
    </script>
</body>
</html>

